/**
 * LFCC v0.9 RC - AI Annotation Types
 * @see docs/product/LFCC_v0.9_RC_Engineering_Docs/01_Kernel_API_Specification.md Section 4
 *
 * Extends the base annotation system with AI-specific types and capabilities.
 */

import type { DisplayAnnoState, GraceToken, StoredAnnoState } from "./types";

// ============================================================================
// AI Annotation Kinds
// ============================================================================

/** User-created annotation kinds */
export type UserAnnotationKind = "highlight" | "comment" | "bookmark" | "note";

/** AI-generated annotation kinds */
export type AIAnnotationKind =
  | "ai_summary" // AI-generated paragraph/section summary
  | "ai_definition" // AI-identified term definition
  | "ai_question" // AI-generated comprehension question
  | "ai_connection" // AI-discovered cross-document link
  | "ai_correction" // AI-suggested text correction
  | "ai_translation" // AI translation annotation
  | "ai_entity" // AI-identified named entity
  | "ai_keyphrase"; // AI-extracted key phrase

/** All annotation kinds */
export type AnnotationKind = UserAnnotationKind | AIAnnotationKind;

// ============================================================================
// AI Annotation Payloads
// ============================================================================

/** Base payload fields for all AI annotations */
type AIPayloadBase = {
  /** AI model used for generation */
  model: string;
  /** Generation timestamp */
  generatedAt: number;
  /** Confidence score (0-1) */
  confidence: number;
  /** Whether this was auto-generated or user-triggered */
  autoGenerated: boolean;
};

/** Summary annotation payload */
export type AISummaryPayload = AIPayloadBase & {
  kind: "ai_summary";
  /** Generated summary text */
  summary: string;
  /** Key points extracted */
  keyPoints: string[];
  /** Summary style: brief, detailed, bullet */
  style: "brief" | "detailed" | "bullet";
};

/** Definition annotation payload */
export type AIDefinitionPayload = AIPayloadBase & {
  kind: "ai_definition";
  /** The term being defined */
  term: string;
  /** Definition text */
  definition: string;
  /** Source of definition */
  source: "inferred" | "dictionary" | "context" | "external";
  /** Related terms */
  relatedTerms?: string[];
};

/** Question annotation payload */
export type AIQuestionPayload = AIPayloadBase & {
  kind: "ai_question";
  /** Generated question */
  question: string;
  /** Question type */
  questionType: "comprehension" | "critical" | "application" | "synthesis";
  /** Suggested answer (optional) */
  suggestedAnswer?: string;
  /** Difficulty level */
  difficulty: "easy" | "medium" | "hard";
};

/** Cross-document connection payload */
export type AIConnectionPayload = AIPayloadBase & {
  kind: "ai_connection";
  /** Target document ID */
  targetDocId: string;
  /** Target annotation ID (if linking to specific annotation) */
  targetAnnoId?: string;
  /** Relationship type */
  relationshipType: "supports" | "contradicts" | "extends" | "references" | "similar";
  /** Explanation of the connection */
  explanation: string;
  /** Bidirectional link ID (if reciprocal link exists) */
  reciprocalLinkId?: string;
};

/** Correction suggestion payload */
export type AICorrectionPayload = AIPayloadBase & {
  kind: "ai_correction";
  /** Original text */
  originalText: string;
  /** Suggested correction */
  suggestedText: string;
  /** Type of correction */
  correctionType: "grammar" | "spelling" | "style" | "factual" | "clarity";
  /** Explanation for the correction */
  explanation: string;
  /** Whether user has reviewed */
  reviewed: boolean;
  /** Whether user accepted the correction */
  accepted?: boolean;
};

/** Translation payload */
export type AITranslationPayload = AIPayloadBase & {
  kind: "ai_translation";
  /** Source language code */
  sourceLanguage: string;
  /** Target language code */
  targetLanguage: string;
  /** Translated text */
  translatedText: string;
  /** Alternative translations */
  alternatives?: string[];
  /** Pronunciation guide (for non-Latin scripts) */
  pronunciation?: string;
};

/** Named entity payload */
export type AIEntityPayload = AIPayloadBase & {
  kind: "ai_entity";
  /** Entity text */
  entityText: string;
  /** Entity type */
  entityType: "person" | "organization" | "location" | "date" | "concept" | "other";
  /** Normalized/canonical form */
  canonicalForm?: string;
  /** External ID (e.g., Wikidata QID) */
  externalId?: string;
  /** Brief description */
  description?: string;
};

/** Key phrase payload */
export type AIKeyphrasePayload = AIPayloadBase & {
  kind: "ai_keyphrase";
  /** The key phrase */
  phrase: string;
  /** Importance score (0-1) */
  importance: number;
  /** Category/topic */
  category?: string;
  /** Related phrases in the document */
  relatedPhrases?: string[];
};

/** Union of all AI annotation payloads */
export type AIAnnotationPayload =
  | AISummaryPayload
  | AIDefinitionPayload
  | AIQuestionPayload
  | AIConnectionPayload
  | AICorrectionPayload
  | AITranslationPayload
  | AIEntityPayload
  | AIKeyphrasePayload;

// ============================================================================
// AI-Enhanced State Machine Events
// ============================================================================

/** AI-specific state machine events */
export type AIAnnoEvent =
  | { type: "AI_PREDICT_ORPHAN"; confidence: number; reason: string }
  | {
      type: "AI_SUGGEST_REPAIR";
      newAnchor: { blockId: string; offset: number };
      confidence: number;
    }
  | { type: "AI_REPAIR_APPROVED" }
  | { type: "AI_REPAIR_REJECTED" }
  | { type: "AI_CONFLICT_DETECTED"; conflictingAnnoIds: string[] };

/** Extended annotation context with AI fields */
export type AIAnnoContext = {
  annoId: string;
  storedState: StoredAnnoState;
  displayState: DisplayAnnoState;
  graceToken: GraceToken | null;
  graceExpiresAtMs: number | null;
  /** AI-related extensions */
  ai?: {
    /** Pending repair suggestion */
    pendingRepair?: {
      newAnchor: { blockId: string; offset: number };
      confidence: number;
      suggestedAt: number;
    };
    /** Original content hash for fuzzy recovery */
    contentHash?: string;
    /** Original content (for fuzzy matching) */
    originalContent?: string;
    /** Last successful verification timestamp */
    lastVerifiedAt?: number;
    /** Number of times AI has repaired this annotation */
    repairCount?: number;
  };
};

// ============================================================================
// Fuzzy Recovery Types
// ============================================================================

/** Options for AI-powered anchor recovery */
export type AIAnchorRecoveryOptions = {
  /** Enable semantic embedding matching */
  useSemanticMatching: boolean;
  /** Minimum confidence threshold */
  minConfidence: number;
  /** Auto-apply repairs above this confidence */
  autoRepairThreshold: number;
  /** Maximum repair attempts before giving up */
  maxRepairAttempts: number;
  /** Extend grace period during AI recovery */
  extendGraceDuringRecovery: boolean;
  /** Grace period extension multiplier */
  graceExtensionMultiplier: number;
};

/** Default AI recovery options */
export const DEFAULT_AI_RECOVERY_OPTIONS: AIAnchorRecoveryOptions = {
  useSemanticMatching: false, // Start with text-based only
  minConfidence: 0.7,
  autoRepairThreshold: 0.95,
  maxRepairAttempts: 3,
  extendGraceDuringRecovery: true,
  graceExtensionMultiplier: 2,
};

/** Result of AI anchor recovery attempt */
export type AIAnchorRecoveryResult = {
  success: boolean;
  method: "exact" | "integrity" | "fuzzy_text" | "fuzzy_semantic" | "failed";
  confidence: number;
  newAnchor?: { blockId: string; offset: number };
  requiresUserApproval: boolean;
  debug?: {
    candidatesConsidered: number;
    bestMatchPreview?: string;
    searchRadiusUsed: number;
    timeElapsedMs: number;
  };
};

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Check if an annotation kind is AI-generated
 */
export function isAIAnnotationKind(kind: AnnotationKind): kind is AIAnnotationKind {
  return kind.startsWith("ai_");
}

/**
 * Check if an annotation kind is user-created
 */
export function isUserAnnotationKind(kind: AnnotationKind): kind is UserAnnotationKind {
  return !kind.startsWith("ai_");
}

/**
 * Get display name for annotation kind
 */
export function getAnnotationKindDisplayName(kind: AnnotationKind): string {
  const names: Record<AnnotationKind, string> = {
    highlight: "Highlight",
    comment: "Comment",
    bookmark: "Bookmark",
    note: "Note",
    ai_summary: "AI Summary",
    ai_definition: "AI Definition",
    ai_question: "AI Question",
    ai_connection: "AI Connection",
    ai_correction: "AI Correction",
    ai_translation: "AI Translation",
    ai_entity: "AI Entity",
    ai_keyphrase: "AI Key Phrase",
  };
  return names[kind] ?? kind;
}
